#!/usr/bin/env python3

# This file is part of the Python aiocoap library project.
#
# Copyright (c) 2012-2014 Maciej Wasilak <http://sixpinetrees.blogspot.com/>,
#               2013-2014 Christian Ams√ºss <c.amsuess@energyharvesting.at>
#
# txThings is free software, this file is published under the MIT license as
# described in the accompanying LICENSE file.

"""coap-proxy is a plain CoAP proxy that forwards incoming requests."""

import sys
import logging
import asyncio
import copy

import aiocoap

class CanNotRedirect(Exception):
    def __init__(self, code, explanation):
        super(CanNotRedirect, self).__init__()
        self.code = code
        self.explanation = explanation

class CanNotRedirectBecauseOfUnsafeOptions(CanNotRedirect):
    def __init__(self, options):
        self.code = aiocoap.BAD_OPTION
        self.explanation = "Unsafe options in request: %s"%(", ".join(str(o.number) for o in options))
        self.options = options

def raise_unless_safe(request, known_options):
    """Raise a BAD_OPTION CanNotRedirect unless all options in request are
    safe to forward or known"""

    known_options = set(known_options).union({aiocoap.numbers.OptionNumber.URI_HOST, aiocoap.numbers.OptionNumber.URI_PATH})

    unsafe_options = [o for o in request.opt.option_list() if o.number.is_unsafe() and o.number not in known_options]
    if unsafe_options:
        raise CanNotRedirectBecauseOfUnsafeOptions(unsafe_options)

class Proxy():
    def __init__(self):
        self._redirectors = []

    def add_redirector(self, redirector):
        self._redirectors.append(redirector)

    def apply_redirection(self, request):
        for r in self._redirectors:
            result = r.apply_redirection(request)
            if result is not None:
                return result
        return None

class ForwardProxy(Proxy):
    def apply_redirection(self, request):
        if request.opt.proxy_uri is not None:
            raise CanNotRedirect(aiocoap.NOT_IMPLEMENTED, "URI splitting not implemented, please use Proxy-Scheme.")
        if request.opt.proxy_scheme is None:
            raise CanNotRedirect(aiocoap.BAD_REQUEST, "This is only a proxy.") # correct error code?
        if request.opt.proxy_scheme != 'coap':
            raise CanNotRedirect(aiocoap.BAD_OPTION, "This is only a CoAP proxy (set uri-scheme to coap)")

        redirected = super(ForwardProxy, self).apply_redirection(request)
        if redirected is not None:
            return redirected

        try:
            raise_unless_safe(request, (aiocoap.numbers.OptionNumber.PROXY_SCHEME, aiocoap.numbers.OptionNumber.URI_HOST))
        except CanNotRedirect as c:
            # this should just be raised
            logging.warn("Ignoring unsafe request options %r"%unsafe_options)

        return request

class ReverseProxy(Proxy):
    def apply_redirection(self, request):
        if request.opt.proxy_uri is not None or request.opt.proxy_scheme is not None:
            # that should somehow be default...
            raise CanNotRedirect(aiocoap.PROXYING_NOT_SUPPORTED, "This is a reverse proxy, not a forward one.")

        redirected = super(ReverseProxy, self).apply_redirection(request)
        if redirected is None:
            raise CanNotRedirect(aiocoap.NOT_FOUND, "")

        return redirected

class Redirector():
    def apply_redirection(self, request):
        return None

class NameBasedVirtualHost(Redirector):
    def __init__(self, match_name, target):
        self.match_name = match_name
        self.target = target

    def apply_redirection(self, request):
        raise_unless_safe(request, ())

        if request.opt.uri_host == self.match_name:
            request.opt.uri_host = self.target
            return request

class UnconditionalRedirector(Redirector):
    def __init__(self, target):
        self.target = target

    def apply_redirection(self, request):
        raise_unless_safe(request, ())

        request.opt.uri_host = self.target
        return request

class SubresourceVirtualHost(Redirector):
    def __init__(self, path, target):
        self.path = tuple(path)
        self.target = target

    def apply_redirection(self, request):
        raise_unless_safe(request, ())

        if self.path == request.opt.uri_path[:len(self.path)]:
            request.opt.uri_path = request.opt.uri_path[len(self.path):]
            request.opt.uri_host = self.target
            return request

class ProxiedResource():
    def __init__(self, context, proxy):
        self.context = context
        self.proxy = proxy

    observable = False

    @asyncio.coroutine
    def render(self, request):
        # FIXME i'd rather let the application do with the message whatever it
        # wants. everything the responder needs of the request should be
        # extracted beforehand.
        request = copy.copy(request)

        request.mid = None
        request.remote = None
        request.token = None

        try:
            request = self.proxy.apply_redirection(request)
        except CanNotRedirect as e:
            return aiocoap.Message(code=e.code, payload=e.explanation.encode('utf8'))

        response = yield from self.context.request(request).response

        unsafe_options = [o.value for o in response.opt.option_list() if o.number.is_unsafe() and o.number not in ()]
        if unsafe_options:
            logging.warn("Ignoring unsafe response options %r"%unsafe_options)
            # return aiocoap.Message(code=aiocoap.BAD_GATEWAY, b"Unsafe options in response")


        response.mid = None
        response.remote = None
        response.token = None

        return response

class ProxySite():
    def __init__(self, proxy):
        self.proxy = proxy

    def get_resource_for(self, request):
        return ProxiedResource(self.context, self.proxy)

@asyncio.coroutine
def main(args):
    proxy = ReverseProxy()
    proxy.add_redirector(SubresourceVirtualHost(('foo', 'bar'), '192.168.1.2'))
    proxy.add_redirector(NameBasedVirtualHost('localhost', '192.168.1.2'))
    proxysite = ProxySite(proxy)

    proxy_context = yield from aiocoap.Context.create_server_context(proxysite, dump_to='/tmp/proxy-in.log')
    outgoing_context = yield from aiocoap.Context.create_client_context(dump_to='/tmp/proxy-out.log')

    proxysite.context = outgoing_context

if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)
    try:
        loop = asyncio.get_event_loop()
        loop.run_until_complete(main(sys.argv[1:]))
        logging.info("proxy ready")
        loop.run_forever()
    except KeyboardInterrupt:
        sys.exit(3)
