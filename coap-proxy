#!/usr/bin/env python3

# This file is part of the Python aiocoap library project.
#
# Copyright (c) 2012-2014 Maciej Wasilak <http://sixpinetrees.blogspot.com/>,
#               2013-2014 Christian Ams√ºss <c.amsuess@energyharvesting.at>
#
# aiocoap is free software, this file is published under the MIT license as
# described in the accompanying LICENSE file.

"""a plain CoAP proxy that can work both as forward and as reverse proxy"""

import sys
import logging
import asyncio
import copy
import argparse
import urllib.parse

import aiocoap

class CanNotRedirect(Exception):
    def __init__(self, code, explanation):
        super(CanNotRedirect, self).__init__()
        self.code = code
        self.explanation = explanation

class CanNotRedirectBecauseOfUnsafeOptions(CanNotRedirect):
    def __init__(self, options):
        self.code = aiocoap.BAD_OPTION
        self.explanation = "Unsafe options in request: %s"%(", ".join(str(o.number) for o in options))
        self.options = options

def raise_unless_safe(request, known_options):
    """Raise a BAD_OPTION CanNotRedirect unless all options in request are
    safe to forward or known"""

    known_options = set(known_options).union({
        # it is expected that every proxy is aware of these options even though
        # one of them often doesn't need touching
        aiocoap.numbers.OptionNumber.URI_HOST,
        aiocoap.numbers.OptionNumber.URI_PATH,
        # handled by the Context
        aiocoap.numbers.OptionNumber.BLOCK1,
        aiocoap.numbers.OptionNumber.BLOCK2,
        })

    unsafe_options = [o for o in request.opt.option_list() if o.number.is_unsafe() and o.number not in known_options]
    if unsafe_options:
        raise CanNotRedirectBecauseOfUnsafeOptions(unsafe_options)

class Proxy():
    def __init__(self):
        self._redirectors = []

    def add_redirector(self, redirector):
        self._redirectors.append(redirector)

    def apply_redirection(self, request):
        for r in self._redirectors:
            result = r.apply_redirection(request)
            if result is not None:
                return result
        return None

class ForwardProxy(Proxy):
    def apply_redirection(self, request):
        if request.opt.proxy_uri is not None:
            raise CanNotRedirect(aiocoap.NOT_IMPLEMENTED, "URI splitting not implemented, please use Proxy-Scheme.")
        if request.opt.proxy_scheme is None:
            raise CanNotRedirect(aiocoap.BAD_REQUEST, "This is only a proxy.") # correct error code?
        if request.opt.proxy_scheme != 'coap':
            raise CanNotRedirect(aiocoap.BAD_OPTION, "This is only a CoAP proxy (set uri-scheme to coap)")

        request.opt.proxy_scheme = None

        redirected = super(ForwardProxy, self).apply_redirection(request)
        if redirected is not None:
            return redirected

        try:
            raise_unless_safe(request, (aiocoap.numbers.OptionNumber.PROXY_SCHEME, aiocoap.numbers.OptionNumber.URI_HOST))
        except CanNotRedirectBecauseOfUnsafeOptions as c:
            # this should just be raised
            logging.warn("Ignoring unsafe request options %r"%c)

        return request

class ReverseProxy(Proxy):
    def apply_redirection(self, request):
        if request.opt.proxy_uri is not None or request.opt.proxy_scheme is not None:
            # that should somehow be default...
            raise CanNotRedirect(aiocoap.PROXYING_NOT_SUPPORTED, "This is a reverse proxy, not a forward one.")

        redirected = super(ReverseProxy, self).apply_redirection(request)
        if redirected is None:
            raise CanNotRedirect(aiocoap.NOT_FOUND, "")

        return redirected

class Redirector():
    def apply_redirection(self, request):
        return None

def splitport(hostport):
    """Like urllib.parse.splitport, but return port as int, and as None if it
    equals the CoAP default port. Also, it allows giving IPv6 addresses like a netloc:

    >>> splitport('foo:5683')
    ('foo', None)
    >>> splitport('[::1]:56830')
    ('::1', 56830)
    """

    pseudoparsed = urllib.parse.SplitResult(None, hostport, None, None, None)
    host, port = pseudoparsed.hostname, pseudoparsed.port
    if port == aiocoap.COAP_PORT:
        port = None
    return host, port

class NameBasedVirtualHost(Redirector):
    def __init__(self, match_name, target, rewrite_uri_host=False):
        self.match_name = match_name
        self.target = target
        self.rewrite_uri_host = rewrite_uri_host

    def apply_redirection(self, request):
        raise_unless_safe(request, ())

        if request.opt.uri_host == self.match_name:
            if self.rewrite_uri_host:
                request.opt.uri_host, request.opt.uri_port = splitport(self.target)
            else:
                request.unresolved_remote = self.target
            return request

class UnconditionalRedirector(Redirector):
    def __init__(self, target):
        self.target = target

    def apply_redirection(self, request):
        raise_unless_safe(request, ())

        request.unresolved_remote = target
        return request

class SubresourceVirtualHost(Redirector):
    def __init__(self, path, target):
        self.path = tuple(path)
        self.target = target

    def apply_redirection(self, request):
        raise_unless_safe(request, ())

        if self.path == request.opt.uri_path[:len(self.path)]:
            request.opt.uri_path = request.opt.uri_path[len(self.path):]
            request.opt.uri_host, request.opt.uri_port = splitport(self.target)
            return request

class ProxiedResource(aiocoap.interfaces.Resource):
    def __init__(self, context, proxy):
        self.context = context
        self.proxy = proxy

    @asyncio.coroutine
    def render(self, request):
        # FIXME i'd rather let the application do with the message whatever it
        # wants. everything the responder needs of the request should be
        # extracted beforehand.
        request = copy.copy(request)

        request.mid = None
        request.remote = None
        request.token = None

        try:
            request = self.proxy.apply_redirection(request)
        except CanNotRedirect as e:
            return aiocoap.Message(code=e.code, payload=e.explanation.encode('utf8'))

        response = yield from self.context.request(request).response

        try:
            raise_unless_safe(response, ())
        except CanNotRedirectBecauseOfUnsafeOptions as c:
            logging.warn("Ignoring unsafe response options %r"%c)
            # return aiocoap.Message(code=aiocoap.BAD_GATEWAY, b"Unsafe options in response")


        response.mtype = None
        response.mid = None
        response.remote = None
        response.token = None

        return response

def parse_commandline(args):
    p = argparse.ArgumentParser(description=__doc__)

    mode = p.add_argument_group("mode", "Required argument for setting the operation mode")
    mode.add_argument('--forward', help="Run as forward proxy", action='store_const', const=ForwardProxy, dest='direction')
    mode.add_argument('--reverse', help="Run as reverse proxy", action='store_const', const=ReverseProxy, dest='direction')

    details = p.add_argument_group("details", "Options that govern how requests go in and out")
    details.add_argument('--server-address', help="Address to bind the server context to", metavar="HOST", default="::")
    details.add_argument('--server-port', help="Port to bind the server context to", metavar="PORT", default=aiocoap.COAP_PORT, type=int)
    details.add_argument('--proxy', help="Relay outgoing requests through yet another proxy", metavar="HOST[:PORT]")
    r = p.add_argument_group('Rules', description="Sequence of forwarding rules that, if matched by a request, specify a forwarding destination")
    class TypedAppend(argparse.Action):
        def __call__(self, parser, namespace, values, option_string=None):
            if getattr(namespace, self.dest) is None:
                setattr(namespace, self.dest, [])
            getattr(namespace, self.dest).append((option_string, values))
    r.add_argument('--namebased', help="If Uri-Host matches NAME, route to DEST", metavar="NAME:DEST", action=TypedAppend, dest='r')
    r.add_argument('--pathbased', help="If a requested path starts with PATH, split that part off and route to DEST", metavar="PATH:DEST", action=TypedAppend, dest='r')
    r.add_argument('--unconditional', help="Route all requests not previously matched to DEST", metavar="DEST", action=TypedAppend, dest='r')

    return p, p.parse_args(args)

@asyncio.coroutine
def main(args):
    parser, options = parse_commandline(args)

    if options.direction is None:
        raise parser.error("Either --forward or --reverse must be given.")

    proxy = options.direction()
    for kind, data in options.r or ():
        if kind == '--namebased':
            try:
                name, dest = data.split(':', 1)
            except:
                raise parser.error("--namebased needs NAME:DEST as arguments")
            r = NameBasedVirtualHost(name, dest)
        elif kind == '--pathbased':
            try:
                path, dest = data.split(':', 1)
            except:
                raise parser.error("--pathbased needs PATH:DEST as arguments")
            r = SubresourceVirtualHost(path.spit('/'), dest)
        elif kind == '--unconditional':
            r = UnconditionalRedirector(data)
        else:
            raise AssertionError('Unknown redirectory kind')
        proxy.add_redirector(r)

    outgoing_context = yield from aiocoap.Context.create_client_context(dump_to='/tmp/proxy-out.log')
    proxysite = ProxiedResource(outgoing_context, proxy)
    proxy_context = yield from aiocoap.Context.create_server_context(proxysite, dump_to='/tmp/proxy-in.log', bind=(options.server_address, options.server_port))

if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)
    try:
        loop = asyncio.get_event_loop()
        loop.run_until_complete(main(sys.argv[1:]))
        logging.info("proxy ready")
        loop.run_forever()
    except KeyboardInterrupt:
        sys.exit(3)
