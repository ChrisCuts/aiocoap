#!/usr/bin/env python3

# This file is part of the Python aiocoap library project.
#
# Copyright (c) 2012-2014 Maciej Wasilak <http://sixpinetrees.blogspot.com/>,
#               2013-2014 Christian Ams√ºss <c.amsuess@energyharvesting.at>
#
# aiocoap is free software, this file is published under the MIT license as
# described in the accompanying LICENSE file.

"""A client suitable for running the OSCORE plug test series against a given
server

See https://github.com/EricssonResearch/OSCOAP for the test suite
description."""

import argparse
import asyncio
import logging
import signal
import functools
from pathlib import Path

from aiocoap import *
from aiocoap import interfaces
from aiocoap import credentials

from plugtest_common import *


class PlugtestClientProgram:
    async def run(self):
        p = argparse.ArgumentParser(description="Client for the OSCORE plug test.")
        p.add_argument("host", help="Hostname of the server")
        p.add_argument("testno", type=int, help="Test number to run (integer part)")
        p.add_argument("contextdir", help="Directory name where to persist sequence numbers", type=Path)
        p.add_argument("--verbose", help="Show aiocoap debug messages", action='store_true')
        opts = p.parse_args()

        self.host = opts.host

        # this also needs to be called explicitly as only the
        # 'logging.warning()'-style functions will call it; creating a
        # sub-logger and logging from there makes the whole logging system not
        # emit the 'WARNING' prefixes that set apart log messages from regular
        # prints and also help the test suite catch warnings and errors
        if opts.verbose:
            logging.basicConfig(level=logging.DEBUG)
        else:
            logging.basicConfig(level=logging.WARNING)

        security_context_ab = get_security_context('ab', 'client', opts.contextdir / "ab")
        security_context_cd = get_security_context('cd', 'client', opts.contextdir / "cd")

        self.ctx = await Context.create_client_context()
        self.ctx.client_credentials[":ab"] = security_context_ab
        self.ctx.client_credentials[":cd"] = security_context_cd

        try:
            await self.run_test(opts.testno)
        except oscore.NotAProtectedMessage as e:
            print("Response carried no Object-Security option, but was: %s %s"%(e.plain_message, e.plain_message.payload))
            raise

    def use_context(self, which):
        if which is None:
            self.ctx.client_credentials.pop("coap://%s/*" % self.host, None)
        else:
            self.ctx.client_credentials["coap://%s/*" % self.host] = ":" + which

    @classmethod
    def sync_run(cls):
        loop = asyncio.get_event_loop()
        task = cls().run()
        # Having SIGTERM cause a more graceful shutdown allow for output
        # buffers to be flushed when the unit test program instrumenting it
        # terminates it.
        signal.signal(signal.SIGTERM,
                lambda signo, frame: task.throw(KeyboardInterrupt))
        loop.run_until_complete(task)


    async def run_test(self, testno):
        self.testno = testno
        testfun = self.__methods[testno]
        await getattr(self, testfun)()

    __methods = {}
    def __implements_tests(numbers, __methods=__methods):
        def registerer(method):
            for n in numbers:
                __methods[n] = method.__name__
            return method
        return registerer

    @__implements_tests([0])
    async def test_plain(self):
        request = Message(code=GET, uri='coap://' + self.host + '/oscore/hello/coap')

        self.use_context(None)

        response = await self.ctx.request(request).response

        print("Response:", response)
        additional_verify("Responde had correct code", response.code, CONTENT)
        additional_verify("Responde had correct payload", response.payload, b"Hello World!")
        additional_verify("Options as expected", response.opt, Message(content_format=0).opt)

    @__implements_tests([1, 2])
    async def test_hello12(self):
        if self.testno == 1:
            self.use_context("ab")
        else:
            self.use_context("cd")

        request = Message(code=GET, uri='coap://' + self.host+ '/oscore/hello/1')
        expected = {'content_format': 0}
        unprotected_response = await self.ctx.request(request).response

        print("Unprotected response:", unprotected_response)
        additional_verify("Code as expected", unprotected_response.code, CONTENT)
        additional_verify("Options as expected", unprotected_response.opt, Message(**expected).opt)
        additional_verify("Payload as expected", unprotected_response.payload, b"Hello World!")

    @__implements_tests([3])
    async def test_hellotest3(self):
        self.use_context("ab")

        request = Message(code=GET, uri='coap://' + self.host+ '/oscore/hello/2?first=1')
        expected = {'content_format': 0, 'etag': b'\x2b'}
        unprotected_response = await self.ctx.request(request).response

        print("Unprotected response:", unprotected_response)
        additional_verify("Code as expected", unprotected_response.code, CONTENT)
        additional_verify("Options as expected", unprotected_response.opt, Message(**expected).opt)
        additional_verify("Payload as expected", unprotected_response.payload, b"Hello World!")

    @__implements_tests([4])
    async def test_hellotest4(self):
        self.use_context("ab")

        request = Message(code=GET, uri='coap://' + self.host+ '/oscore/hello/3', accept=0)
        expected = {'content_format': 0, 'max_age': 5}
        unprotected_response = await self.ctx.request(request).response

        print("Unprotected response:", unprotected_response)
        additional_verify("Code as expected", unprotected_response.code, CONTENT)
        additional_verify("Options as expected", unprotected_response.opt, Message(**expected).opt)
        additional_verify("Payload as expected", unprotected_response.payload, b"Hello World!")

    @__implements_tests([5])
    async def test_nonobservable(self):
        self.use_context("ab")

        request = Message(code=GET, uri='coap://' + self.host + '/oscore/hello/1', observe=0)

        request = self.ctx.request(request)

        unprotected_response = await request.response

        print("Unprotected response:", unprotected_response)
        additional_verify("Code as expected", unprotected_response.code, CONTENT)
        additional_verify("Observe option is absent", unprotected_response.opt.observe, None)

        async for o in request.observation:
            print("Expectation failed: Observe events coming in.")

# 6, 7: observe cancelled by server, client
#     @__implements_tests([5])
#     async def test_observable(self):
#         request = Message(code=GET, uri='coap://' + self.host + '/oscore/observe', observe=0)
# 
#         request = self.ctx.request(request)
# 
#         unprotected_response = await request.response
# 
#         print("Unprotected response:", unprotected_response)
#         additional_verify("Code as expected", unprotected_response.code, CONTENT)
#         additional_verify("Observe option present", unprotected_response.opt.observe is not None, True)
# 
#         payloads = []
# 
#         async for o in request.observation:
#             payloads.append(o.payload)
#             print("Verify: Received message", o, o.payload)
# 
#         if not payloads:
#             print("Failed: Observation ended with no notifications.")
# 
#         if b'Zwei' in payloads:
#             # be more strict: this is our own test server that should give exactly 5 responses
#             additional_verify("Own server gave the expected responses", payloads, [b'Zwei', b'Drei', b'und aus!', b'server is bored with client'])

    @__implements_tests([8])
    async def test_post(self):
        self.use_context("ab")

        request = Message(code=POST, uri='coap://' + self.host+ '/oscore/hello/6', payload=b"\x4a", content_format=0)
        unprotected_response = await self.ctx.request(request).response

        print("Unprotected response:", unprotected_response)
        additional_verify("Code as expected", CREATED, unprotected_response.code)
        additional_verify("Options as expected", unprotected_response.opt, Message(content_format=0).opt)
        additional_verify("Payload as expected", unprotected_response.payload, b"\x4a")

    @__implements_tests([9])
    async def test_put_match(self):
        self.use_context("ab")

        request = Message(code=PUT, uri='coap://' + self.host+ '/oscore/hello/7', payload=b"\x7a", content_format=0, if_match=[b"\x7b"])
        unprotected_response = await self.ctx.request(request).response

        print("Unprotected response:", unprotected_response)
        additional_verify("Code as expected", CHANGED, unprotected_response.code)
        additional_verify("Options empty as expected", Message(content_format=0).opt, unprotected_response.opt)
        additional_verify("Payload as expected", unprotected_response.payload, b"\x7a")

    @__implements_tests([10])
    async def test_put_nonmatch(self):
        self.use_context("ab")

        request = Message(code=PUT, uri='coap://' + self.host+ '/oscore/hello/7', payload=b"\x8a", content_format=0, if_none_match=True)
        unprotected_response = await self.ctx.request(request).response

        print("Unprotected response:", unprotected_response)
        additional_verify("Code as expected", PRECONDITION_FAILED, unprotected_response.code)
        additional_verify("Options empty as expected", Message().opt, unprotected_response.opt)

    @__implements_tests([11])
    async def test_delete(self):
        self.use_context("ab")

        request = Message(code=DELETE, uri='coap://' + self.host+ '/oscore/test')
        unprotected_response = await self.ctx.request(request).response

        print("Unprotected response:", unprotected_response)
        additional_verify("Code as expected", DELETED, unprotected_response.code)
        additional_verify("Options empty as expected", Message().opt, unprotected_response.opt)

#     @__implements_tests([10, 11])
#     async def test_oscoreerror_server_reports_error(self):
#         request = Message(code=GET, uri='coap://' + self.host + '/oscore/hello/1')
# 
#         if self.testno == 10:
#             expected_code = UNAUTHORIZED
#         elif self.testno == 11:
#             expected_code = BAD_REQUEST
# 
#         try:
#             unprotected_response = await self.ctx.request(request).response
#         except oscore.NotAProtectedMessage as e:
#             if e.plain_message.code == expected_code:
#                 print("Check passed: The server responded with unencrypted %s."%(expected_code))
#             else:
#                 print("Failed: Server responded with something unencrypted, but not the expected code %s: %s"%(expected_code, e.plain_message))
#         else:
#             print("Failed: The validation passed.")
#             print("Unprotected response:", unprotected_response)
# 
#     @__implements_tests([12])
#     async def test_oscoreerror_failclientside(self):
#         request = Message(code=GET, uri='coap://' + self.host + '/oscore/hello/1')
# 
#         try:
#             unprotected_response = await self.ctx.request(request).response
#         except oscore.ProtectionInvalid as e:
#             print("Check passed: The validation failed. (%s)"%e)
#         else:
#             print("Failed: the validation passed.")
#             print("Unprotected response:", unprotected_response)
# 
#     @__implements_tests([13])
#     async def test_replay(self):
#         request = Message(code=GET, uri='coap://' + self.host + '/oscore/hello/1')
# 
#         unprotected_response = await self.ctx.request(request).response # make this _nonraising as soon as there's a proper context backend
#         if unprotected_response.code != CONTENT:
#             print("Failed: Request did not even pass before replay (%s)"%unprotected_response)
#             return
# 
#         security_context = get_security_context(self.testno, 'ab', 'client')
#         self.ctx.client_credentials["coap://%s/*" % self.host] = security_context
# 
#         try:
#             unprotected_response = await self.ctx.request(request).response
#         except oscore.NotAProtectedMessage as e:
#             if e.plain_message.code == SERVICE_UNAVAILABLE:
#                 print("Check passed: The server responded with unencrypted replay error.")
#             else:
#                 print("Failed: Server responded with something unencrypted, but not the expected code %s: %s"%(expected_code, e.plain_message))
#         else:
#             print("Failed: the validation passed.")
#             print("Unprotected response:", unprotected_response)
# 
#     # unofficial blockwise tests start here
# 
#     @__implements_tests([16, 17])
#     async def test_block2(self):
#         #request = Message(code=GET, uri='coap://' + self.host + '/oscore/block/' + {16: 'outer', 17: 'inner'}[self.testno])
#         request = Message(code=GET, uri='coap://' + self.host + '/oscore/LargeResource')
# 
#         expected = {'content_format': 0}
#         unprotected_response = await self.ctx.request(request, handle_blockwise=True).response
#         if self.testno == 17:
#             # the library should probably strip that
#             expected['block2'] = optiontypes.BlockOption.BlockwiseTuple(block_number=1, more=False, size_exponent=6)
# 
#         print("Unprotected response:", unprotected_response)
#         additional_verify("Code as expected", unprotected_response.code, CONTENT)
#         additional_verify("Options as expected", unprotected_response.opt, Message(**expected).opt)

if __name__ == "__main__":
    PlugtestClientProgram.sync_run()
